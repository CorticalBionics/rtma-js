// This message def file was auto-generated by pyrtma.compile version 2.2.1

export { RTMA } ;

// Type Map Default Values
const type_map = {};
type_map.char = () => "";
type_map.unsigned_char = () => 0;
type_map.byte = () => 0;
type_map.int = () => 0;
type_map.signed_int = () => 0;
type_map.unsigned_int = () => 0;
type_map.unsigned = () => 0;
type_map.short = () => 0;
type_map.signed_short = () => 0;
type_map.unsigned_short = () => 0;
type_map.long = () => 0;
type_map.signed_long = () => 0;
type_map.unsigned_long = () => 0;
type_map.long_long = () => 0;
type_map.signed_long_long = () => 0;
type_map.unsigned_long_long = () => 0;
type_map.float = () => 0;
type_map.double = () => 0;
type_map.uint8 = () => 0;
type_map.uint16 = () => 0;
type_map.uint32 = () => 0;
type_map.uint64 = () => 0;
type_map.int8 = () => 0;
type_map.int16 = () => 0;
type_map.int32 = () => 0;
type_map.int64 = () => 0;

// Top-Level RTMA object
const RTMA = {};
RTMA.COMPILED_PYRTMA_VERSION = "2.2.1";

// Constants
RTMA.constants =  {};
RTMA.constants.MAX_MODULES = 200;
RTMA.constants.DYN_MOD_ID_START = 100;
RTMA.constants.MAX_HOSTS = 5;
RTMA.constants.MAX_MESSAGE_TYPES = 10000;
RTMA.constants.MIN_STREAM_TYPE = 9000;
RTMA.constants.MAX_TIMERS = 100;
RTMA.constants.MAX_INTERNAL_TIMERS = 20;
RTMA.constants.MAX_RTMA_MSG_TYPE = 99;
RTMA.constants.MAX_RTMA_MODULE_ID = 9;
RTMA.constants.MAX_LOGGER_FILENAME_LENGTH = 256;
RTMA.constants.MAX_CONTIGUOUS_MESSAGE_DATA = 9000;
RTMA.constants.ALL_MESSAGE_TYPES = 2147483647;
RTMA.constants.MAX_SPIKE_SOURCES = 2;
RTMA.constants.MAX_SPIKE_SOURCES_N256 = 1;
RTMA.constants.MAX_SPIKE_CHANS_PER_SOURCE = 128;
RTMA.constants.MAX_SPIKE_CHANS_PER_SOURCE_N256 = 256;
RTMA.constants.MAX_COINCIDENT_SPIKES = 45;
RTMA.constants.MAX_ANALOG_CHANS = 16;
RTMA.constants.MAX_UNITS_PER_CHAN = 5;
RTMA.constants.MAX_TOTAL_SPIKE_CHANS_PER_SOURCE = 640;
RTMA.constants.MAX_TOTAL_SPIKE_CHANS_PER_SOURCE_N256 = 1280;
RTMA.constants.MAX_TOTAL_SPIKE_CHANS = 1280;
RTMA.constants.MAX_TOTAL_SPIKE_CHANS_N256 = 1280;
RTMA.constants.LFPSAMPLES_PER_HEARTBEAT = 10;
RTMA.constants.ANALOGSAMPLES_PER_HEARTBEAT = 10;
RTMA.constants.RAW_COUNTS_PER_SAMPLE = 2;
RTMA.constants.SAMPLE_LENGTH_MS = 20;
RTMA.constants.SAMPLE_LENGTH = 0.02;
RTMA.constants.SNIPPETS_PER_MESSAGE = 25;
RTMA.constants.SAMPLES_PER_SNIPPET = 48;
RTMA.constants.MAX_DIG_PER_SAMPLE = 10;
RTMA.constants.MAX_DATAGLOVE_SENSORS = 18;
RTMA.constants.NUM_DOMAINS = 6;
RTMA.constants.MAX_COMMAND_DIMS = 30;
RTMA.constants.MPL_RAW_PERCEPT_DIMS = 54;
RTMA.constants.NUM_STIM_CHANS = 64;
RTMA.constants.SHAM_STIM_CHANS = 32;
RTMA.constants.MAX_STIM_CHANS_ON = 12;
RTMA.constants.PULSE_TRAIN_SIZE = 101;
RTMA.constants.MAX_CS_CONFIGS = 16;
RTMA.constants.NUM_SPIKES_PER_STIM_MSG = 26;
RTMA.constants.MAX_XIPP_EEG_HEADSTAGES = 2;
RTMA.constants.MAX_XIPP_CHANS = 64;
RTMA.constants.MAX_XIPP_ANALOG_CHANS = 32;
RTMA.constants.XIPP_SAMPLES_PER_MSG = 20;
RTMA.constants.MAX_MYO_EMG_CHANS = 8;
RTMA.constants.MYO_SAMPLES_PER_MSG = 4;
RTMA.constants.GRIP_DIMS_R = 1;
RTMA.constants.GRIP_DIMS_L = 1;
RTMA.constants.MAX_GRIP_DIMS = 9;
RTMA.constants.MAX_GRIPPER_DIMS = 1;
RTMA.constants.MAX_GRIPPER_JOINT_ANGLES = 5;
RTMA.constants.MAX_GRIPPER_FORCES = 5;
RTMA.constants.MJ_MAX_MOTOR = 1;
RTMA.constants.MJ_MAX_JOINT = 5;
RTMA.constants.MJ_MAX_CONTACT = 5;
RTMA.constants.NoResult = -1;
RTMA.constants.SuccessfulTrial = 1;
RTMA.constants.BadTrial = 2;
RTMA.constants.ManualProceed = 4;
RTMA.constants.ManualFail = 8;
RTMA.constants.HX_DEKA_LUKE_CONTACT_COUNT = 13;
RTMA.constants.HX_LUKE_MOTOR_COUNT = 6;
RTMA.constants.NUM_FINGERS = 3;
RTMA.constants.NUM_SENSORS_PER_FINGER = 9;
RTMA.constants.NUM_SENSORS_PALM = 11;
RTMA.constants.NUM_TAKKTILE = 38;
RTMA.constants.NUM_ENCODERS = 3;
RTMA.constants.NUM_SERVOS = 4;
RTMA.constants.NUM_DYNAMIXEL = 4;
RTMA.constants.MECH_STIM_SINE = 1;
RTMA.constants.MECH_STIM_RAMP_AND_HOLD = 2;
RTMA.constants.DEKA_DOF_COUNT = 7;
RTMA.constants.KUKA_DOF_COUNT = 7;
RTMA.constants.PRENSILIA_DOF = 5;
RTMA.constants.PRENSILIA_EXT_SENSORS = 7;
RTMA.constants.TAG_LENGTH = 64;
RTMA.constants.MPL_AT_ARM_EPV_FING_JV = 0;
RTMA.constants.MPL_AT_ARM_EPV_FING_JP = 1;
RTMA.constants.MPL_AT_ARM_JV_FING_JP = 2;
RTMA.constants.MPL_AT_ALL_JV = 3;
RTMA.constants.MPL_AT_ALL_JP = 4;
RTMA.constants.MPL_AT_ARM_EPP_FING_JP = 5;
RTMA.constants.TFD_FREQ_BINS = 20;

// String Constants
RTMA.constants.DEFAULT_MM_IP = "localhost:7111";

// Type Aliases
RTMA.aliases =  {};

RTMA.aliases.MODULE_ID = type_map.short();
RTMA.aliases.HOST_ID = type_map.short();
RTMA.aliases.MSG_TYPE = type_map.int();
RTMA.aliases.MSG_COUNT = type_map.int();
RTMA.aliases.SPIKE_COUNT_DATA_TYPE = type_map.unsigned_char();

// Host IDs
RTMA.HID =  {};

RTMA.HID.LOCAL_HOST = 0;
RTMA.HID.ALL_HOSTS = 32767;

// Module IDs
RTMA.MID =  {};

RTMA.MID.MESSAGE_MANAGER = 0;
RTMA.MID.QUICK_LOGGER = 5;
RTMA.MID.JSTICK_COMMAND = 10;
RTMA.MID.COMBINER = 11;
RTMA.MID.CEREBUS = 12;
RTMA.MID.RAW_LOGGER = 16;
RTMA.MID.INPUT_TRANSFORM = 20;
RTMA.MID.RPPL_RECORD = 21;
RTMA.MID.CENTRAL = 22;
RTMA.MID.EXTRACTION = 30;
RTMA.MID.MYO = 31;
RTMA.MID.MECH_STIM_MODULE = 39;
RTMA.MID.MPL_CONTROL = 40;
RTMA.MID.GRIP_CONTROL = 41;
RTMA.MID.DEKA_CAN_MODULE = 42;
RTMA.MID.DEKA_ACI_RESPONSE = 43;
RTMA.MID.DEKA_DISPLAY = 44;
RTMA.MID.PSYCHTLBX = 46;
RTMA.MID.STIM_PRESENT = 48;
RTMA.MID.ACTIVE_ASSIST = 50;
RTMA.MID.KUKA_DISPLAY = 51;
RTMA.MID.ROBOTICS_FEEDBACK_INTEGRATOR = 52;
RTMA.MID.KUKA_INTERFACE_MODULE = 53;
RTMA.MID.KUKA_JOINT_COMMAND_DISPLAY = 54;
RTMA.MID.KUKA_DIAGNOSTICS = 55;
RTMA.MID.FORCE_PLATFORM = 58;
RTMA.MID.FORCE_PLATFORM_DISPLAY = 59;
RTMA.MID.MPL_FEEDBACK = 60;
RTMA.MID.AJA_CONTROL = 65;
RTMA.MID.SEAIOCONTROL = 66;
RTMA.MID.EXECUTIVE = 70;
RTMA.MID.COMMENT_MANAGER = 71;
RTMA.MID.FLIP_THAT_BUCKET_MESSENGER = 74;
RTMA.MID.VOLTAGE_MONITOR_GUI = 76;
RTMA.MID.VOLTAGE_MONITOR = 77;
RTMA.MID.ATIsensor = 78;
RTMA.MID.FOFIX = 79;
RTMA.MID.STIM_THRESH_GAME = 80;
RTMA.MID.MESSAGERATES = 81;
RTMA.MID.VISUAL_GRATING = 85;
RTMA.MID.BIASMODULE = 86;
RTMA.MID.CURSOR = 87;
RTMA.MID.RHR_COMMAND_MODULE = 88;
RTMA.MID.RHR_SENSOR_MODULE = 89;
RTMA.MID.SOUNDPLAYER = 90;
RTMA.MID.RFDISPLAY = 91;
RTMA.MID.RFACTIVITY = 92;
RTMA.MID.ImageDisplayer = 93;
RTMA.MID.FLIP_THAT_BUCKET = 94;
RTMA.MID.STIM_SAFETY_MODULE = 95;
RTMA.MID.SENSOR_STIM_TRANS_MODULE = 96;
RTMA.MID.CERESTIM_CONTROL = 97;
RTMA.MID.SENSE_TOUCH_INTERFACE = 98;
RTMA.MID.SENSOR_STIM_TRANSFORM_PY = 99;

// Message Type IDs
RTMA.MT = {};

RTMA.MT.EXIT = 0;
RTMA.MT.KILL = 1;
RTMA.MT.ACKNOWLEDGE = 2;
RTMA.MT.FAIL_SUBSCRIBE = 6;
RTMA.MT.FAILED_MESSAGE = 8;
RTMA.MT.CONNECT = 13;
RTMA.MT.DISCONNECT = 14;
RTMA.MT.SUBSCRIBE = 15;
RTMA.MT.UNSUBSCRIBE = 16;
RTMA.MT.MODULE_READY = 26;
RTMA.MT.LM_EXIT = 55;
RTMA.MT.SAVE_MESSAGE_LOG = 56;
RTMA.MT.MESSAGE_LOG_SAVED = 57;
RTMA.MT.PAUSE_MESSAGE_LOGGING = 58;
RTMA.MT.RESUME_MESSAGE_LOGGING = 59;
RTMA.MT.RESET_MESSAGE_LOG = 60;
RTMA.MT.DUMP_MESSAGE_LOG = 61;
RTMA.MT.TIMING_MESSAGE = 80;
RTMA.MT.FORCE_DISCONNECT = 82;
RTMA.MT.PAUSE_SUBSCRIPTION = 85;
RTMA.MT.RESUME_SUBSCRIPTION = 86;
RTMA.MT.LM_READY = 96;
RTMA.MT.JSON_CONFIG = 1200;
RTMA.MT.FINISHED_COMMAND = 1700;
RTMA.MT.CONTROL_SPACE_FEEDBACK = 1701;
RTMA.MT.CONTROL_SPACE_COMMAND = 1702;
RTMA.MT.MPL_RAW_PERCEPT = 1703;
RTMA.MT.BIAS_COMMAND = 1704;
RTMA.MT.MPL_REBIASED_SENSORDATA = 1705;
RTMA.MT.CONTROL_SPACE_FEEDBACK_RHR_GRIPPER = 1706;
RTMA.MT.CONTROL_SPACE_POS_COMMAND = 1710;
RTMA.MT.MPL_SEGMENT_PERCEPTS = 1711;
RTMA.MT.WAM_FEEDBACK = 1712;
RTMA.MT.IMPEDANCE_COMMAND = 1713;
RTMA.MT.EXECUTIVE_CTRL = 1714;
RTMA.MT.CURSOR_FEEDBACK = 1720;
RTMA.MT.VISUAL_GRATING_BUILD = 1721;
RTMA.MT.VISUAL_GRATING_RESPONSE = 1722;
RTMA.MT.GRIP_COMMAND = 1730;
RTMA.MT.GRIP_FINISHED_COMMAND = 1731;
RTMA.MT.GRIPPER_FEEDBACK = 1732;
RTMA.MT.OPENHAND_CMD = 1740;
RTMA.MT.OPENHAND_SENS = 1741;
RTMA.MT.PRENSILIA_SENS = 1742;
RTMA.MT.PRENSILIA_CMD = 1743;
RTMA.MT.TABLE_LOAD_CELLS = 1744;
RTMA.MT.REZERO_GRIPPER_SENSORS = 1745;
RTMA.MT.SINGLETACT_DATA = 1760;
RTMA.MT.GET_USER_RESPONSE = 1761;
RTMA.MT.USER_RESPONSE_L = 1762;
RTMA.MT.USER_RESPONSE_R = 1763;
RTMA.MT.RAW_SPIKECOUNT = 1800;
RTMA.MT.SPM_SPIKECOUNT = 1801;
RTMA.MT.SPIKE_SNIPPET = 1802;
RTMA.MT.RAW_CTSDATA = 1803;
RTMA.MT.SPM_CTSDATA = 1804;
RTMA.MT.REJECTED_SNIPPET = 1805;
RTMA.MT.RAW_DIGITAL_EVENT = 1806;
RTMA.MT.SPM_DIGITAL_EVENT = 1807;
RTMA.MT.STIM_SYNC_EVENT = 1808;
RTMA.MT.STIM_UPDATE_EVENT = 1809;
RTMA.MT.CENTRALRECORD = 1810;
RTMA.MT.RAW_ANALOGDATA = 1811;
RTMA.MT.SPM_ANALOGDATA = 1812;
RTMA.MT.RAW_SPIKECOUNT_N256 = 1815;
RTMA.MT.RAW_CTSDATA_N256 = 1816;
RTMA.MT.MECH_SYNC_EVENT = 1817;
RTMA.MT.SAMPLE_GENERATED = 1820;
RTMA.MT.XIPP_EMG_DATA_RAW = 1830;
RTMA.MT.MYO_EMG_DATA = 1831;
RTMA.MT.MYO_KIN_DATA = 1832;
RTMA.MT.INPUT_DOF_DATA = 1850;
RTMA.MT.DATAGLOVE = 1860;
RTMA.MT.OPTITRACK_RIGID_BODY = 1861;
RTMA.MT.TASK_STATE_CONFIG = 1900;
RTMA.MT.PHASE_RESULT = 1901;
RTMA.MT.EXTRACTION_RESPONSE = 1902;
RTMA.MT.NORMALIZATION_FACTOR = 1903;
RTMA.MT.TRIAL_METADATA = 1904;
RTMA.MT.EXTRACTION_REQUEST = 1905;
RTMA.MT.UPDATE_UNIT_STATE = 1906;
RTMA.MT.DISABLED_UNITS = 1907;
RTMA.MT.TRIAL_END = 1910;
RTMA.MT.REP_START = 1911;
RTMA.MT.REP_END = 1912;
RTMA.MT.EXEC_SCORE = 1913;
RTMA.MT.FLIP_THAT_BUCKET_DATA = 1914;
RTMA.MT.SET_START = 1915;
RTMA.MT.SET_END = 1916;
RTMA.MT.BLOCK_START = 1917;
RTMA.MT.BLOCK_END = 1918;
RTMA.MT.SET_METADATA = 1919;
RTMA.MT.EXEC_PAUSE = 1950;
RTMA.MT.EM_ADAPT_NOW = 2000;
RTMA.MT.EM_CONFIGURATION = 2001;
RTMA.MT.TDMS_CREATE = 2002;
RTMA.MT.RF_REPORT = 2003;
RTMA.MT.PICDISPLAY = 2004;
RTMA.MT.STIMDATA = 2005;
RTMA.MT.SEAIO_OUT = 2007;
RTMA.MT.ATIforcesensor = 2008;
RTMA.MT.TACTOR_CMD = 2009;
RTMA.MT.HSTLOG = 3000;
RTMA.MT.STIM_INTERVAL = 3001;
RTMA.MT.USER_SHOT_L = 3002;
RTMA.MT.USER_SHOT_R = 3003;
RTMA.MT.STIM_THRESH = 3004;
RTMA.MT.GAME_ROUND_INFO = 3005;
RTMA.MT.USER_SHOT = 3006;
RTMA.MT.GAME_HEARTBEAT_REQUEST = 3007;
RTMA.MT.GAME_HEARTBEAT_RESPONSE = 3008;
RTMA.MT.PLAYSOUND = 3100;
RTMA.MT.PLAYVIDEO = 3102;
RTMA.MT.START_TIMED_RECORDING = 3101;
RTMA.MT.AJA_CONFIG = 3200;
RTMA.MT.AJA_TIMECODE = 3201;
RTMA.MT.AJA_STATUS = 3202;
RTMA.MT.AJA_STATUS_REQUEST = 3203;
RTMA.MT.FOFIX_PROMPT = 3600;
RTMA.MT.FOFIX_INPUT = 3601;
RTMA.MT.FOFIX_MISSED = 3602;
RTMA.MT.FOFIX_STIM = 3603;
RTMA.MT.FOFIX_KEY = 3604;
RTMA.MT.CERESTIM_CONFIG_MODULE = 4000;
RTMA.MT.CERESTIM_CONFIG_CHAN_PRESAFETY = 4001;
RTMA.MT.CERESTIM_CONFIG_CHAN = 4002;
RTMA.MT.CERESTIM_ERROR = 4003;
RTMA.MT.CERESTIM_ALIVE = 4004;
RTMA.MT.CS_TRAIN_END = 4005;
RTMA.MT.CERESTIM_CONFIG_CHAN_PRESAFETY_ARBITRARY = 4006;
RTMA.MT.CERESTIM_CONFIG_CHAN_ARBITRARY = 4007;
RTMA.MT.CS_ARBITRARY_CLOSE = 4008;
RTMA.MT.STIM_VOLTAGE_MONITOR_DATA = 4009;
RTMA.MT.STIM_VOLTAGE_MONITOR_DIGITAL_DATA = 4010;
RTMA.MT.VOLTAGE_MONITOR_STATUS = 4011;
RTMA.MT.STIM_DUTYCYCLE_TIME = 4012;
RTMA.MT.STIM_TRIAL_DURATION = 4013;
RTMA.MT.CERESTIM_HEARTBEAT = 4014;
RTMA.MT.CERESTIM_HEARTBEAT_RQST = 4015;
RTMA.MT.CERESTIM_SAFETY_ALIVE = 4016;
RTMA.MT.CERESTIM_SAFETY_ALIVE_RQST = 4017;
RTMA.MT.NATURAL_RESPONSE = 4050;
RTMA.MT.DEPTH_RESPONSE = 4051;
RTMA.MT.PAIN_RESPONSE = 4052;
RTMA.MT.OVERALL_INTENSITY_RESPONSE = 4053;
RTMA.MT.OTHER_RESPONSE = 4054;
RTMA.MT.MECH_RESPONSE = 4055;
RTMA.MT.MOVE_RESPONSE = 4056;
RTMA.MT.TINGLE_RESPONSE = 4057;
RTMA.MT.TEMP_RESPONSE = 4058;
RTMA.MT.DIR_PIXEL_COORDS = 4059;
RTMA.MT.PIXEL_COORDS = 4060;
RTMA.MT.HOTSPOT_COORDS = 4061;
RTMA.MT.CLEAR_LINE = 4062;
RTMA.MT.CLEAR_HOTSPOT = 4063;
RTMA.MT.ADD_SENSATION = 4064;
RTMA.MT.SLIDER_DATA = 4065;
RTMA.MT.USER_DEFINED_STIM = 4067;
RTMA.MT.USER_BEHAVIOUR = 4068;
RTMA.MT.STOP_STIM = 4069;
RTMA.MT.PAUSE_TRIAL = 4070;
RTMA.MT.CST_LAMBDA = 4100;
RTMA.MT.CST_SETTINGS = 4101;
RTMA.MT.STIM_PRES_CONFIG = 4150;
RTMA.MT.STIM_PRES_PHASE_END = 4151;
RTMA.MT.STIM_PRESENT = 4152;
RTMA.MT.STIM_PRES_STATUS = 4153;
RTMA.MT.STIM_CONFIG_TYPE = 4154;
RTMA.MT.DEKA_ACI_RESPONSE = 4200;
RTMA.MT.DEKA_SENSOR = 4201;
RTMA.MT.DEKA_CAN_TOGGLE = 4202;
RTMA.MT.DEKA_CAN_GRIP_TOGGLE = 4203;
RTMA.MT.DEKA_CAN_EXIT = 4204;
RTMA.MT.DEKA_HAND_SENSOR = 4205;
RTMA.MT.DEKA_HAND_JSTICK_CMD = 4206;
RTMA.MT.RH_GRIPPER_SENSOR = 4207;
RTMA.MT.KUKA_JOINT_COMMAND = 4208;
RTMA.MT.KUKA_FEEDBACK = 4209;
RTMA.MT.KUKA_EXIT = 4210;
RTMA.MT.KUKA_PTP_JOINT = 4211;
RTMA.MT.KUKA_DEBUG = 4212;
RTMA.MT.VEML7700_SYNC = 4248;
RTMA.MT.VEML7700_DATA = 4249;
RTMA.MT.VEML7700_PING = 4250;
RTMA.MT.VEML7700_PONG = 4251;
RTMA.MT.VEML7700_START = 4252;
RTMA.MT.VEML7700_STOP = 4253;
RTMA.MT.VEML7700_RESET = 4254;
RTMA.MT.VEML7700_CONNECT = 4256;
RTMA.MT.MECH_STIM_CONFIGURE = 4260;
RTMA.MT.MECH_STIM_RESET = 4261;
RTMA.MT.MECH_STIM_STAGE = 4262;
RTMA.MT.MECH_STIM_WAITING = 4263;
RTMA.MT.MECH_STIM_TRIGGER = 4264;
RTMA.MT.MECH_STIM_CANCEL = 4265;
RTMA.MT.MECH_STIM_DONE = 4266;
RTMA.MT.MECH_STIM_ERROR = 4267;
RTMA.MT.UC_MECH_STIM_CONFIGURE = 4268;

// Struct Definitions
RTMA.SDF = {};

RTMA.SDF.RTMA_MSG_HEADER = () => {
	return {
		msg_type: RTMA.aliases.MSG_TYPE(),
		msg_count: RTMA.aliases.MSG_COUNT(),
		send_time: type_map.double(),
		recv_time: type_map.double(),
		src_host_id: RTMA.aliases.HOST_ID(),
		src_mod_id: RTMA.aliases.MODULE_ID(),
		dest_host_id: RTMA.aliases.HOST_ID(),
		dest_mod_id: RTMA.aliases.MODULE_ID(),
		num_data_bytes: type_map.int(),
		remaining_bytes: type_map.int(),
		is_dynamic: type_map.int(),
		reserved: type_map.unsigned_int()
	}
};

RTMA.SDF.MSG_HEADER = () => {
	return {
		serial_no: type_map.int(),
		sub_sample: type_map.int()
	}
};

RTMA.SDF.SPIKE_SNIPPET_TYPE = () => {
	return {
		source_index: type_map.int(),
		channel: type_map.short(),
		unit: type_map.unsigned_char(),
		reserved1: type_map.unsigned_char(),
		source_timestamp: type_map.double(),
		fPattern: Array(3).fill(type_map.double()),
		nPeak: type_map.short(),
		nValley: type_map.short(),
		reserved2: type_map.int(),
		snippet: Array(48).fill(type_map.short())
	}
};

RTMA.SDF.REJECTED_SNIPPET_TYPE = () => {
	return {
		source_index: type_map.int(),
		channel: type_map.short(),
		unit: type_map.unsigned_char(),
		reserved1: type_map.unsigned_char(),
		source_timestamp: type_map.double(),
		fPattern: Array(3).fill(type_map.double()),
		nPeak: type_map.short(),
		nValley: type_map.short(),
		rejectType: type_map.int(),
		snippet: Array(48).fill(type_map.short())
	}
};

RTMA.SDF.DEKA_CAN_MSG = () => {
	return {
		can_id: type_map.unsigned_int(),
		data: Array(8).fill(type_map.unsigned_char()),
		padding: type_map.int()
	}
};

RTMA.SDF.RH_FINGER_DATA = () => {
	return {
		proximal_angle: type_map.float(),
		distal_angle: type_map.float(),
		pressure: Array(9).fill(type_map.float()),
		contact: Array(9).fill(type_map.int())
	}
};

RTMA.SDF.DYNAMIXEL_INFO = () => {
	return {
		joint_angle: Array(4).fill(type_map.float()),
		raw_angle: Array(4).fill(type_map.float()),
		velocity: Array(4).fill(type_map.float()),
		load: Array(4).fill(type_map.float()),
		voltage: Array(4).fill(type_map.float()),
		temperature: Array(4).fill(type_map.int())
	}
};

// Message Definitions
RTMA.MDF = {};

RTMA.MDF.EXIT = () => { return {} };

RTMA.MDF.KILL = () => { return {} };

RTMA.MDF.ACKNOWLEDGE = () => { return {} };

RTMA.MDF.FAIL_SUBSCRIBE = () => {
	return {
		mod_id: RTMA.aliases.MODULE_ID(),
		reserved: type_map.short(),
		msg_type: RTMA.aliases.MSG_TYPE()
	}
};

RTMA.MDF.FAILED_MESSAGE = () => {
	return {
		dest_mod_id: RTMA.aliases.MODULE_ID(),
		reserved: Array(3).fill(type_map.short()),
		time_of_failure: type_map.double(),
		msg_header: RTMA.SDF.RTMA_MSG_HEADER()
	}
};

RTMA.MDF.CONNECT = () => {
	return {
		logger_status: type_map.short(),
		daemon_status: type_map.short()
	}
};

RTMA.MDF.DISCONNECT = () => { return {} };

RTMA.MDF.SUBSCRIBE = () => {
	return {
		msg_type: RTMA.aliases.MSG_TYPE()
	}
};

RTMA.MDF.UNSUBSCRIBE = () => {
	return {
		msg_type: RTMA.aliases.MSG_TYPE()
	}
};

RTMA.MDF.MODULE_READY = () => {
	return {
		pid: type_map.int()
	}
};

RTMA.MDF.LM_EXIT = () => { return {} };

RTMA.MDF.SAVE_MESSAGE_LOG = () => {
	return {
		pathname: Array(256).fill(type_map.char()),
		pathname_length: type_map.int()
	}
};

RTMA.MDF.MESSAGE_LOG_SAVED = () => { return {} };

RTMA.MDF.PAUSE_MESSAGE_LOGGING = () => { return {} };

RTMA.MDF.RESUME_MESSAGE_LOGGING = () => { return {} };

RTMA.MDF.RESET_MESSAGE_LOG = () => { return {} };

RTMA.MDF.DUMP_MESSAGE_LOG = () => { return {} };

RTMA.MDF.TIMING_MESSAGE = () => {
	return {
		timing: Array(10000).fill(type_map.unsigned_short()),
		ModulePID: Array(200).fill(type_map.int()),
		send_time: type_map.double()
	}
};

RTMA.MDF.FORCE_DISCONNECT = () => {
	return {
		mod_id: type_map.int()
	}
};

RTMA.MDF.PAUSE_SUBSCRIPTION = () => {
	return {
		msg_type: RTMA.aliases.MSG_TYPE()
	}
};

RTMA.MDF.RESUME_SUBSCRIPTION = () => {
	return {
		msg_type: RTMA.aliases.MSG_TYPE()
	}
};

RTMA.MDF.LM_READY = () => { return {} };

RTMA.MDF.JSON_CONFIG = () => {
	return {
		src: type_map.int(),
		dest: type_map.int(),
		json_config: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.FINISHED_COMMAND = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		command: Array(30).fill(type_map.double()),
		stiffness: Array(54).fill(type_map.double()),
		src: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.CONTROL_SPACE_FEEDBACK = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		position: Array(30).fill(type_map.double()),
		velocity: Array(30).fill(type_map.double())
	}
};

RTMA.MDF.CONTROL_SPACE_COMMAND = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		command: Array(30).fill(type_map.double()),
		dZ: Array(9).fill(type_map.double()),
		src: type_map.int(),
		actual_pos: type_map.int()
	}
};

RTMA.MDF.MPL_RAW_PERCEPT = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		position: Array(54).fill(type_map.double()),
		velocity: Array(54).fill(type_map.double()),
		torque: Array(54).fill(type_map.double()),
		temperature: Array(54).fill(type_map.double())
	}
};

RTMA.MDF.BIAS_COMMAND = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		command: Array(30).fill(type_map.double()),
		dZ: Array(9).fill(type_map.double()),
		src: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.MPL_REBIASED_SENSORDATA = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		torque: Array(54).fill(type_map.double()),
		ind_force: Array(14).fill(type_map.double()),
		mid_force: Array(14).fill(type_map.double()),
		rng_force: Array(14).fill(type_map.double()),
		lit_force: Array(14).fill(type_map.double()),
		thb_force: Array(14).fill(type_map.double()),
		contacts: Array(16).fill(type_map.short())
	}
};

RTMA.MDF.CONTROL_SPACE_FEEDBACK_RHR_GRIPPER = () => { return {} };

RTMA.MDF.CONTROL_SPACE_POS_COMMAND = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		command: Array(30).fill(type_map.double()),
		src: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.MPL_SEGMENT_PERCEPTS = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		ind_force: Array(14).fill(type_map.double()),
		mid_force: Array(14).fill(type_map.double()),
		rng_force: Array(14).fill(type_map.double()),
		lit_force: Array(14).fill(type_map.double()),
		thb_force: Array(14).fill(type_map.double()),
		ind_accel: Array(3).fill(type_map.double()),
		mid_accel: Array(3).fill(type_map.double()),
		rng_accel: Array(3).fill(type_map.double()),
		lit_accel: Array(3).fill(type_map.double()),
		thb_accel: Array(3).fill(type_map.double()),
		contacts: Array(16).fill(type_map.short())
	}
};

RTMA.MDF.WAM_FEEDBACK = () => {
	return {
		position: Array(7).fill(type_map.double()),
		velocity: Array(7).fill(type_map.double())
	}
};

RTMA.MDF.IMPEDANCE_COMMAND = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		stiffness: Array(54).fill(type_map.double()),
		src: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.EXECUTIVE_CTRL = () => {
	return {
		proceed: type_map.short(),
		fail: type_map.short(),
		reserved: type_map.int()
	}
};

RTMA.MDF.CURSOR_FEEDBACK = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		torque: Array(54).fill(type_map.double()),
		ind_force: Array(14).fill(type_map.double()),
		mid_force: Array(14).fill(type_map.double()),
		rng_force: Array(14).fill(type_map.double()),
		lit_force: Array(14).fill(type_map.double()),
		thb_force: Array(14).fill(type_map.double()),
		contacts: Array(16).fill(type_map.short())
	}
};

RTMA.MDF.VISUAL_GRATING_BUILD = () => {
	return {
		grating_visibility: type_map.short(),
		stimulation_on: type_map.short(),
		trial_set: type_map.short(),
		presentation: type_map.short(),
		increment_block: type_map.short(),
		wait_response: type_map.short(),
		reserved: type_map.short()
	}
};

RTMA.MDF.VISUAL_GRATING_RESPONSE = () => {
	return {
		channel: type_map.short(),
		session_num: type_map.short(),
		set_num: type_map.short(),
		block_num: type_map.short(),
		trial_num: type_map.short(),
		block_ID: type_map.short(),
		DELTA_reference_frequency: type_map.short(),
		response: type_map.short(),
		ICMS_reference_frequency: type_map.float(),
		ICMS_reference_amplitude: type_map.float(),
		ICMS_frequency_1: type_map.float(),
		ICMS_frequency_2: type_map.float(),
		ICMS_amplitude_1: type_map.float(),
		ICMS_amplitude_2: type_map.float(),
		VIS_reference_frequency: type_map.float(),
		VIS_reference_amplitude: type_map.float(),
		VIS_frequency_1: type_map.float(),
		VIS_frequency_2: type_map.float(),
		VIS_amplitude_1: type_map.float(),
		VIS_amplitude_2: type_map.float()
	}
};

RTMA.MDF.GRIP_COMMAND = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		grip_pos: Array(1).fill(type_map.double()),
		velocity: Array(1).fill(type_map.double()),
		force: Array(1).fill(type_map.double()),
		impedance: Array(1).fill(type_map.double()),
		controlMask: Array(4).fill(type_map.short()),
		src: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.GRIP_FINISHED_COMMAND = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		grip_pos: Array(1).fill(type_map.double()),
		velocity: Array(1).fill(type_map.double()),
		force: Array(1).fill(type_map.double()),
		impedance: Array(1).fill(type_map.double()),
		controlMask: Array(4).fill(type_map.short()),
		effector: Array(64).fill(type_map.char())
	}
};

RTMA.MDF.GRIPPER_FEEDBACK = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		grip_pos: Array(1).fill(type_map.double()),
		velocity: Array(1).fill(type_map.double()),
		force: Array(5).fill(type_map.double()),
		effector: Array(64).fill(type_map.char())
	}
};

RTMA.MDF.OPENHAND_CMD = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		motor_sp: Array(2).fill(type_map.unsigned_short()),
		reserved1: Array(2).fill(type_map.unsigned_short()),
		mode: type_map.unsigned_char(),
		reserved2: Array(3).fill(type_map.unsigned_char())
	}
};

RTMA.MDF.OPENHAND_SENS = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		motor_pos: type_map.unsigned_short(),
		force: type_map.unsigned_short()
	}
};

RTMA.MDF.PRENSILIA_SENS = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		stream_type: type_map.unsigned_short(),
		current: Array(5).fill(type_map.unsigned_short()),
		position: Array(5).fill(type_map.unsigned_short()),
		external: Array(7).fill(type_map.unsigned_short()),
		tension: Array(5).fill(type_map.unsigned_short()),
		reserved: type_map.unsigned_short()
	}
};

RTMA.MDF.PRENSILIA_CMD = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		mode: Array(5).fill(type_map.short()),
		command: Array(5).fill(type_map.short())
	}
};

RTMA.MDF.TABLE_LOAD_CELLS = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		left_plate: Array(4).fill(type_map.double()),
		left_plate_mean: type_map.double(),
		center_plate: Array(4).fill(type_map.double()),
		center_plate_mean: type_map.double(),
		right_plate: Array(4).fill(type_map.double()),
		right_plate_mean: type_map.double()
	}
};

RTMA.MDF.REZERO_GRIPPER_SENSORS = () => { return {} };

RTMA.MDF.SINGLETACT_DATA = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		raw_analog: Array(3).fill(type_map.int()),
		padding: type_map.int(),
		force: Array(3).fill(type_map.double())
	}
};

RTMA.MDF.GET_USER_RESPONSE = () => { return {} };

RTMA.MDF.USER_RESPONSE_L = () => { return {} };

RTMA.MDF.USER_RESPONSE_R = () => { return {} };

RTMA.MDF.RAW_SPIKECOUNT = () => {
	return {
		source_index: type_map.int(),
		reserved: type_map.int(),
		source_timestamp: type_map.double(),
		count_interval: type_map.double(),
		counts: Array(640).fill(type_map.unsigned_char())
	}
};

RTMA.MDF.SPM_SPIKECOUNT = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		source_timestamp: Array(2).fill(type_map.double()),
		count_interval: type_map.double(),
		counts: Array(1280).fill(RTMA.aliases.SPIKE_COUNT_DATA_TYPE())
	}
};

RTMA.MDF.SPIKE_SNIPPET = () => {
	return {
		ss: Array(25).fill(RTMA.SDF.SPIKE_SNIPPET_TYPE())
	}
};

RTMA.MDF.RAW_CTSDATA = () => {
	return {
		source_index: type_map.int(),
		num_chans_enabled: type_map.int(),
		source_timestamp: type_map.double(),
		data: Array(1280).fill(type_map.short())
	}
};

RTMA.MDF.SPM_CTSDATA = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		source_timestamp: Array(2).fill(type_map.double()),
		data: Array(5120).fill(type_map.short())
	}
};

RTMA.MDF.REJECTED_SNIPPET = () => {
	return {
		rs: Array(25).fill(RTMA.SDF.REJECTED_SNIPPET_TYPE())
	}
};

RTMA.MDF.RAW_DIGITAL_EVENT = () => {
	return {
		source_index: type_map.int(),
		channel: type_map.int(),
		source_timestamp: type_map.double(),
		data: Array(2).fill(type_map.unsigned_int())
	}
};

RTMA.MDF.SPM_DIGITAL_EVENT = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		source_index: Array(10).fill(type_map.int()),
		source_timestamp: Array(2).fill(type_map.double()),
		byte0: Array(10).fill(type_map.unsigned_short()),
		byte1: Array(10).fill(type_map.unsigned_short()),
		num_events: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.STIM_SYNC_EVENT = () => {
	return {
		source_index: type_map.int(),
		channel: type_map.int(),
		source_timestamp: type_map.double(),
		data: type_map.unsigned_int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.STIM_UPDATE_EVENT = () => {
	return {
		source_index: type_map.int(),
		channel: type_map.int(),
		source_timestamp: type_map.double(),
		data: type_map.unsigned_int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.CENTRALRECORD = () => {
	return {
		pathname: Array(256).fill(type_map.char()),
		subjectID: Array(128).fill(type_map.char()),
		record: type_map.unsigned(),
		reserved: type_map.unsigned()
	}
};

RTMA.MDF.RAW_ANALOGDATA = () => {
	return {
		source_index: type_map.int(),
		num_chans_enabled: type_map.int(),
		source_timestamp: type_map.double(),
		data: Array(160).fill(type_map.short())
	}
};

RTMA.MDF.SPM_ANALOGDATA = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		source_timestamp: Array(2).fill(type_map.double()),
		data: Array(640).fill(type_map.short())
	}
};

RTMA.MDF.RAW_SPIKECOUNT_N256 = () => {
	return {
		source_index: type_map.int(),
		reserved: type_map.int(),
		source_timestamp: type_map.double(),
		count_interval: type_map.double(),
		counts: Array(1280).fill(type_map.unsigned_char())
	}
};

RTMA.MDF.RAW_CTSDATA_N256 = () => {
	return {
		source_index: type_map.int(),
		num_chans_enabled: type_map.int(),
		source_timestamp: type_map.double(),
		data: Array(2560).fill(type_map.short())
	}
};

RTMA.MDF.MECH_SYNC_EVENT = () => {
	return {
		source_index: type_map.int(),
		channel: type_map.int(),
		source_timestamp: type_map.double(),
		data: type_map.unsigned_int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.SAMPLE_GENERATED = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		source_timestamp: Array(2).fill(type_map.double())
	}
};

RTMA.MDF.XIPP_EMG_DATA_RAW = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		num_chans_per_headstage: Array(2).fill(type_map.int()),
		source_timestamp: Array(20).fill(type_map.unsigned_int()),
		data: Array(1280).fill(type_map.float())
	}
};

RTMA.MDF.MYO_EMG_DATA = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		source_timestamp: Array(4).fill(type_map.unsigned_long_long()),
		data: Array(32).fill(type_map.int())
	}
};

RTMA.MDF.MYO_KIN_DATA = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		source_timestamp: type_map.unsigned_long_long(),
		orientation: Array(4).fill(type_map.float()),
		gyroscope: Array(3).fill(type_map.float()),
		acceleration: Array(3).fill(type_map.float())
	}
};

RTMA.MDF.INPUT_DOF_DATA = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		tag: Array(64).fill(type_map.char()),
		dof_vals: Array(30).fill(type_map.double())
	}
};

RTMA.MDF.DATAGLOVE = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		tag: Array(64).fill(type_map.char()),
		raw_vals: Array(18).fill(type_map.double()),
		calib_vals: Array(18).fill(type_map.double()),
		gesture: type_map.int(),
		glovetype: type_map.int(),
		hand: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.OPTITRACK_RIGID_BODY = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		ID: type_map.int(),
		reserved: type_map.int(),
		pos: Array(3).fill(type_map.double()),
		orient: Array(3).fill(type_map.double()),
		timestamp: type_map.double(),
		name: Array(128).fill(type_map.char())
	}
};

RTMA.MDF.TASK_STATE_CONFIG = () => {
	return {
		state_name: Array(128).fill(type_map.char()),
		target: Array(30).fill(type_map.double()),
		active_assist_weight: Array(6).fill(type_map.double()),
		brain_control_weight: Array(6).fill(type_map.double()),
		passive_assist_weight: Array(6).fill(type_map.double()),
		jstick_control_weight: Array(6).fill(type_map.double()),
		gain: Array(6).fill(type_map.double()),
		threshold: Array(6).fill(type_map.double()),
		force_targ: Array(9).fill(type_map.double()),
		dZ_gain: type_map.double(),
		force_thresh: type_map.double(),
		active_override: Array(30).fill(type_map.int()),
		use_for_calib: type_map.int(),
		result_code: type_map.int(),
		stim_enable: type_map.int(),
		force_calib: type_map.int(),
		targ_set: type_map.int(),
		targ_idx: type_map.int(),
		gripperControlMask: Array(4).fill(type_map.short())
	}
};

RTMA.MDF.PHASE_RESULT = () => {
	return {
		state_name: Array(128).fill(type_map.char()),
		target: Array(30).fill(type_map.double()),
		active_assist_weight: Array(6).fill(type_map.double()),
		brain_control_weight: Array(6).fill(type_map.double()),
		passive_assist_weight: Array(6).fill(type_map.double()),
		jstick_control_weight: Array(6).fill(type_map.double()),
		gain: Array(6).fill(type_map.double()),
		threshold: Array(6).fill(type_map.double()),
		force_targ: Array(9).fill(type_map.double()),
		dZ_gain: type_map.double(),
		force_thresh: type_map.double(),
		active_override: Array(30).fill(type_map.int()),
		use_for_calib: type_map.int(),
		result_code: type_map.int(),
		stim_enable: type_map.int(),
		force_calib: type_map.int(),
		targ_set: type_map.int(),
		targ_idx: type_map.int(),
		gripperControlMask: Array(4).fill(type_map.short())
	}
};

RTMA.MDF.EXTRACTION_RESPONSE = () => {
	return {
		src: type_map.int(),
		decoder_type: Array(128).fill(type_map.char()),
		decoder_loc: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.NORMALIZATION_FACTOR = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		factor: type_map.double(),
		length: type_map.double()
	}
};

RTMA.MDF.TRIAL_METADATA = () => {
	return {
		session_num: type_map.int(),
		set_num: type_map.int(),
		block_num: type_map.int(),
		trial_num: type_map.int(),
		session_type: Array(128).fill(type_map.char()),
		subject_id: Array(64).fill(type_map.char())
	}
};

RTMA.MDF.EXTRACTION_REQUEST = () => { return {} };

RTMA.MDF.UPDATE_UNIT_STATE = () => {
	return {
		unit_idx: type_map.int(),
		enabled: type_map.int()
	}
};

RTMA.MDF.DISABLED_UNITS = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		disabled_units: Array(1280).fill(type_map.unsigned_char())
	}
};

RTMA.MDF.TRIAL_END = () => { return {} };

RTMA.MDF.REP_START = () => {
	return {
		rep_num: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.REP_END = () => { return {} };

RTMA.MDF.EXEC_SCORE = () => {
	return {
		passed: type_map.int(),
		failed: type_map.int()
	}
};

RTMA.MDF.FLIP_THAT_BUCKET_DATA = () => {
	return {
		state_name: Array(128).fill(type_map.char()),
		state_value: type_map.double()
	}
};

RTMA.MDF.SET_START = () => {
	return {
		session_num: type_map.int(),
		set_num: type_map.int(),
		session_type: Array(128).fill(type_map.char()),
		subject_id: Array(64).fill(type_map.char())
	}
};

RTMA.MDF.SET_END = () => {
	return {
		session_num: type_map.int(),
		set_num: type_map.int(),
		session_type: Array(128).fill(type_map.char()),
		subject_id: Array(64).fill(type_map.char())
	}
};

RTMA.MDF.BLOCK_START = () => {
	return {
		block_num: type_map.int()
	}
};

RTMA.MDF.BLOCK_END = () => { return {} };

RTMA.MDF.SET_METADATA = () => {
	return {
		session_id: type_map.int(),
		num_blocks: type_map.int(),
		num_trials: type_map.int(),
		stim_trigger: type_map.int(),
		subject_response: type_map.int(),
		reserved: type_map.int(),
		session_type: Array(128).fill(type_map.char()),
		subject_id: Array(64).fill(type_map.char()),
		data_path: Array(128).fill(type_map.char())
	}
};

RTMA.MDF.EXEC_PAUSE = () => {
	return {
		pause: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.EM_ADAPT_NOW = () => { return {} };

RTMA.MDF.EM_CONFIGURATION = () => {
	return {
		type: type_map.int(),
		reserved: type_map.int(),
		data: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.TDMS_CREATE = () => {
	return {
		pathname: Array(256).fill(type_map.char()),
		pathname_length: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.RF_REPORT = () => {
	return {
		handp: Array(48).fill(type_map.char()),
		handd: Array(18).fill(type_map.char()),
		head: Array(13).fill(type_map.char()),
		arms: Array(20).fill(type_map.char()),
		padding: type_map.char(),
		tag: type_map.int(),
		flipframe: type_map.int()
	}
};

RTMA.MDF.PICDISPLAY = () => {
	return {
		filename: Array(256).fill(type_map.char()),
		timer: type_map.double()
	}
};

RTMA.MDF.STIMDATA = () => {
	return {
		ConfigID: Array(12).fill(type_map.double()),
		Vmax: Array(12).fill(type_map.double()),
		Vmin: Array(12).fill(type_map.double()),
		interphase: Array(12).fill(type_map.double())
	}
};

RTMA.MDF.SEAIO_OUT = () => {
	return {
		bit: type_map.int(),
		value: type_map.int()
	}
};

RTMA.MDF.ATIforcesensor = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		Fx: type_map.double(),
		Fy: type_map.double(),
		Fz: type_map.double(),
		Tz: type_map.double(),
		Tx: type_map.double(),
		Ty: type_map.double()
	}
};

RTMA.MDF.TACTOR_CMD = () => { return {} };

RTMA.MDF.HSTLOG = () => {
	return {
		len: type_map.int(),
		reserved: type_map.int(),
		log: Array(512).fill(type_map.char())
	}
};

RTMA.MDF.STIM_INTERVAL = () => {
	return {
		interval: type_map.int()
	}
};

RTMA.MDF.USER_SHOT_L = () => { return {} };

RTMA.MDF.USER_SHOT_R = () => { return {} };

RTMA.MDF.STIM_THRESH = () => {
	return {
		threshold: type_map.double(),
		channel: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.GAME_ROUND_INFO = () => {
	return {
		num_intervals: type_map.int(),
		stim_interval: type_map.int()
	}
};

RTMA.MDF.USER_SHOT = () => {
	return {
		interval: type_map.int()
	}
};

RTMA.MDF.GAME_HEARTBEAT_REQUEST = () => { return {} };

RTMA.MDF.GAME_HEARTBEAT_RESPONSE = () => { return {} };

RTMA.MDF.PLAYSOUND = () => {
	return {
		filename: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.PLAYVIDEO = () => {
	return {
		filename: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.START_TIMED_RECORDING = () => {
	return {
		start_command: type_map.double()
	}
};

RTMA.MDF.AJA_CONFIG = () => {
	return {
		record: type_map.int(),
		stop: type_map.int(),
		filename: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.AJA_TIMECODE = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		timecode: Array(128).fill(type_map.char())
	}
};

RTMA.MDF.AJA_STATUS = () => {
	return {
		status: type_map.int(),
		reserved: type_map.int(),
		clipname: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.AJA_STATUS_REQUEST = () => { return {} };

RTMA.MDF.FOFIX_PROMPT = () => {
	return {
		note: type_map.int(),
		length: type_map.int(),
		target_time: type_map.double(),
		game_time: type_map.double()
	}
};

RTMA.MDF.FOFIX_INPUT = () => {
	return {
		notes_strummed: Array(5).fill(type_map.int()),
		reserved: type_map.short(),
		hit_note: type_map.short(),
		game_time: type_map.double()
	}
};

RTMA.MDF.FOFIX_MISSED = () => {
	return {
		note: type_map.int(),
		reserved: type_map.int(),
		target_time: type_map.double(),
		game_time: type_map.double()
	}
};

RTMA.MDF.FOFIX_STIM = () => {
	return {
		note: type_map.int(),
		condition: type_map.int()
	}
};

RTMA.MDF.FOFIX_KEY = () => {
	return {
		note: type_map.int(),
		enabled: type_map.int()
	}
};

RTMA.MDF.CERESTIM_CONFIG_MODULE = () => {
	return {
		configID: Array(16).fill(type_map.int()),
		amp1: Array(16).fill(type_map.int()),
		amp2: Array(16).fill(type_map.int()),
		frequency: Array(16).fill(type_map.int()),
		num_modules: type_map.int(),
		afcf: type_map.int(),
		width1: type_map.int(),
		width2: type_map.int(),
		interphase: type_map.int()
	}
};

RTMA.MDF.CERESTIM_CONFIG_CHAN_PRESAFETY = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		stop: type_map.int(),
		numChans: type_map.int(),
		channel: Array(64).fill(type_map.int()),
		pattern: Array(64).fill(type_map.int()),
		reps: type_map.int(),
		pause_t: type_map.float()
	}
};

RTMA.MDF.CERESTIM_CONFIG_CHAN = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		stop: type_map.int(),
		numChans: type_map.int(),
		channel: Array(12).fill(type_map.int()),
		pattern: Array(12).fill(type_map.int()),
		reps: type_map.int(),
		pause_t: type_map.float()
	}
};

RTMA.MDF.CERESTIM_ERROR = () => {
	return {
		error: type_map.int(),
		config: type_map.int()
	}
};

RTMA.MDF.CERESTIM_ALIVE = () => { return {} };

RTMA.MDF.CS_TRAIN_END = () => { return {} };

RTMA.MDF.CERESTIM_CONFIG_CHAN_PRESAFETY_ARBITRARY = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		stop: type_map.int(),
		numChans: type_map.int(),
		channel: Array(64).fill(type_map.int()),
		pattern: Array(64).fill(type_map.int()),
		reps: type_map.int(),
		reserved: type_map.int(),
		pathname: Array(256).fill(type_map.char()),
		pathlength: type_map.int()
	}
};

RTMA.MDF.CERESTIM_CONFIG_CHAN_ARBITRARY = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		stop: type_map.int(),
		pathname: Array(256).fill(type_map.char()),
		pathlength: type_map.int(),
		pulselength: type_map.int()
	}
};

RTMA.MDF.CS_ARBITRARY_CLOSE = () => { return {} };

RTMA.MDF.STIM_VOLTAGE_MONITOR_DATA = () => {
	return {
		sample_rate: type_map.int(),
		pulse_count: type_map.int(),
		daq_channel: Array(26).fill(type_map.int()),
		array_channel: Array(26).fill(type_map.int()),
		daq_timestamp: Array(26).fill(type_map.double()),
		voltage: Array(2600).fill(type_map.float()),
		interphase: Array(26).fill(type_map.float()),
		Vmax: Array(26).fill(type_map.float()),
		Vmin: Array(26).fill(type_map.float())
	}
};

RTMA.MDF.STIM_VOLTAGE_MONITOR_DIGITAL_DATA = () => {
	return {
		stim_sync_event: Array(30).fill(type_map.float()),
		stim_param_event: Array(5).fill(type_map.float()),
		padding: type_map.float(),
		spm_daq_delta_t: type_map.double()
	}
};

RTMA.MDF.VOLTAGE_MONITOR_STATUS = () => {
	return {
		msg_length: type_map.int(),
		msg: Array(1024).fill(type_map.char())
	}
};

RTMA.MDF.STIM_DUTYCYCLE_TIME = () => {
	return {
		dutycycle_time: type_map.double()
	}
};

RTMA.MDF.STIM_TRIAL_DURATION = () => {
	return {
		trial_duration: type_map.double()
	}
};

RTMA.MDF.CERESTIM_HEARTBEAT = () => {
	return {
		type: type_map.int()
	}
};

RTMA.MDF.CERESTIM_HEARTBEAT_RQST = () => { return {} };

RTMA.MDF.CERESTIM_SAFETY_ALIVE = () => { return {} };

RTMA.MDF.CERESTIM_SAFETY_ALIVE_RQST = () => { return {} };

RTMA.MDF.NATURAL_RESPONSE = () => {
	return {
		a: type_map.double()
	}
};

RTMA.MDF.DEPTH_RESPONSE = () => {
	return {
		idx: type_map.int(),
		enabled: type_map.int(),
		depth: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.PAIN_RESPONSE = () => {
	return {
		a: type_map.double()
	}
};

RTMA.MDF.OVERALL_INTENSITY_RESPONSE = () => {
	return {
		a: type_map.double()
	}
};

RTMA.MDF.OTHER_RESPONSE = () => {
	return {
		enabled: type_map.int(),
		reserved: type_map.int(),
		a: type_map.double()
	}
};

RTMA.MDF.MECH_RESPONSE = () => {
	return {
		idx: type_map.int(),
		enabled: type_map.int(),
		a: type_map.double(),
		quality: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.MOVE_RESPONSE = () => {
	return {
		idx: type_map.int(),
		enabled: type_map.int(),
		a: type_map.double(),
		quality: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.TINGLE_RESPONSE = () => {
	return {
		idx: type_map.int(),
		enabled: type_map.int(),
		a: type_map.double(),
		quality: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.TEMP_RESPONSE = () => {
	return {
		a: type_map.double(),
		quality: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.DIR_PIXEL_COORDS = () => {
	return {
		img: Array(32).fill(type_map.char()),
		moreMsgs: type_map.int(),
		reserved: type_map.int(),
		pixels: Array(64).fill(type_map.float())
	}
};

RTMA.MDF.PIXEL_COORDS = () => {
	return {
		img: Array(32).fill(type_map.char()),
		moreMsgs: type_map.int(),
		reserved: type_map.int(),
		pixels: Array(64).fill(type_map.float())
	}
};

RTMA.MDF.HOTSPOT_COORDS = () => {
	return {
		img: Array(128).fill(type_map.char()),
		x: type_map.double(),
		y: type_map.double()
	}
};

RTMA.MDF.CLEAR_LINE = () => {
	return {
		img: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.CLEAR_HOTSPOT = () => {
	return {
		img: Array(256).fill(type_map.char())
	}
};

RTMA.MDF.ADD_SENSATION = () => { return {} };

RTMA.MDF.SLIDER_DATA = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		type: type_map.int(),
		channel: type_map.int(),
		value: type_map.int(),
		time: type_map.int()
	}
};

RTMA.MDF.USER_DEFINED_STIM = () => {
	return {
		frequency: type_map.int(),
		amplitude: Array(3).fill(type_map.int()),
		channel: Array(3).fill(type_map.int())
	}
};

RTMA.MDF.USER_BEHAVIOUR = () => {
	return {
		current_trial: type_map.int(),
		current_screen: Array(256).fill(type_map.char()),
		current_object: Array(256).fill(type_map.char()),
		left_canvas: Array(2).fill(type_map.int()),
		right_canvas: Array(2).fill(type_map.int()),
		frequency: type_map.int(),
		freq_choice: type_map.int(),
		bio: type_map.int(),
		drag: type_map.int(),
		amplitude: Array(3).fill(type_map.int()),
		satisfaction: type_map.int(),
		certainty: type_map.int(),
		chosen_object: Array(256).fill(type_map.char()),
		object_quest: Array(6).fill(type_map.int()),
		affective_quest: Array(5).fill(type_map.int())
	}
};

RTMA.MDF.STOP_STIM = () => {
	return {
		stop_stim: type_map.int()
	}
};

RTMA.MDF.PAUSE_TRIAL = () => {
	return {
		pause_trial: type_map.int()
	}
};

RTMA.MDF.CST_LAMBDA = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		cst_lambda: type_map.float(),
		k: type_map.int(),
		cursor_pos: type_map.double()
	}
};

RTMA.MDF.CST_SETTINGS = () => {
	return {
		sweep_rate: type_map.double(),
		vis_bins: type_map.int(),
		stim_bins: type_map.int()
	}
};

RTMA.MDF.STIM_PRES_CONFIG = () => {
	return {
		filename: Array(256).fill(type_map.char()),
		randomization: type_map.int()
	}
};

RTMA.MDF.STIM_PRES_PHASE_END = () => {
	return {
		phase_rep_end: type_map.int()
	}
};

RTMA.MDF.STIM_PRESENT = () => {
	return {
		stim_filename: Array(256).fill(type_map.char()),
		stim_state_name: Array(256).fill(type_map.char()),
		stim_display_time: type_map.double(),
		stim_start_delay: type_map.double()
	}
};

RTMA.MDF.STIM_PRES_STATUS = () => {
	return {
		pause_resume: type_map.int(),
		stop: type_map.int()
	}
};

RTMA.MDF.STIM_CONFIG_TYPE = () => {
	return {
		stim_configtype: Array(128).fill(type_map.char())
	}
};

RTMA.MDF.DEKA_ACI_RESPONSE = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		ACI_1: RTMA.SDF.DEKA_CAN_MSG(),
		ACI_2: RTMA.SDF.DEKA_CAN_MSG(),
		ACI_3: RTMA.SDF.DEKA_CAN_MSG()
	}
};

RTMA.MDF.DEKA_SENSOR = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		position_msg_1: RTMA.SDF.DEKA_CAN_MSG(),
		position_msg_2: RTMA.SDF.DEKA_CAN_MSG(),
		motor_pos: Array(7).fill(type_map.double()),
		motor_current: Array(7).fill(type_map.double()),
		mode: type_map.int(),
		sync: type_map.int(),
		grip: type_map.int(),
		padding: type_map.int()
	}
};

RTMA.MDF.DEKA_CAN_TOGGLE = () => {
	return {
		toggle: type_map.int(),
		padding: type_map.int()
	}
};

RTMA.MDF.DEKA_CAN_GRIP_TOGGLE = () => {
	return {
		toggle: type_map.int(),
		padding: type_map.int()
	}
};

RTMA.MDF.DEKA_CAN_EXIT = () => {
	return {
		exit: type_map.int(),
		padding: type_map.int()
	}
};

RTMA.MDF.DEKA_HAND_SENSOR = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		position_msg_1: RTMA.SDF.DEKA_CAN_MSG(),
		position_msg_2: RTMA.SDF.DEKA_CAN_MSG(),
		force_msg_1: RTMA.SDF.DEKA_CAN_MSG(),
		force_msg_2: RTMA.SDF.DEKA_CAN_MSG(),
		force_msg_3: RTMA.SDF.DEKA_CAN_MSG(),
		motor_pos: Array(6).fill(type_map.double()),
		contact: Array(13).fill(type_map.double()),
		mode: type_map.int(),
		status: Array(13).fill(type_map.int()),
		sync: type_map.int(),
		grip: type_map.int()
	}
};

RTMA.MDF.DEKA_HAND_JSTICK_CMD = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		ref_vel: Array(6).fill(type_map.double())
	}
};

RTMA.MDF.RH_GRIPPER_SENSOR = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		finger_1: RTMA.SDF.RH_FINGER_DATA(),
		finger_2: RTMA.SDF.RH_FINGER_DATA(),
		finger_3: RTMA.SDF.RH_FINGER_DATA(),
		motor_info: RTMA.SDF.DYNAMIXEL_INFO()
	}
};

RTMA.MDF.KUKA_JOINT_COMMAND = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		joint_dest: Array(7).fill(type_map.double()),
		err_move_mode: type_map.int(),
		err_input_cap: Array(6).fill(type_map.int()),
		err_cart_wall_eef: Array(6).fill(type_map.int()),
		err_cart_wall_arm: Array(6).fill(type_map.int()),
		err_jpos_stop: Array(3).fill(type_map.int())
	}
};

RTMA.MDF.KUKA_FEEDBACK = () => {
	return {
		header: RTMA.SDF.MSG_HEADER(),
		time: type_map.double(),
		joint_pos: Array(7).fill(type_map.double()),
		cart_pos: Array(3).fill(type_map.double()),
		cart_angle: Array(3).fill(type_map.double()),
		cart_pos_vel: Array(3).fill(type_map.double()),
		cart_rot_vel: Array(3).fill(type_map.double()),
		cart_force: Array(3).fill(type_map.double()),
		cart_torque: Array(3).fill(type_map.double()),
		dest_delta_t: type_map.double(),
		mode: type_map.int(),
		reserved: type_map.int()
	}
};

RTMA.MDF.KUKA_EXIT = () => {
	return {
		exit: type_map.int(),
		padding: type_map.int()
	}
};

RTMA.MDF.KUKA_PTP_JOINT = () => {
	return {
		joint_pos: Array(7).fill(type_map.double())
	}
};

RTMA.MDF.KUKA_DEBUG = () => {
	return {
		joint_pos: Array(7).fill(type_map.double())
	}
};

RTMA.MDF.VEML7700_SYNC = () => {
	return {
		timestamp: type_map.unsigned_long(),
		sync_idx: type_map.unsigned_long()
	}
};

RTMA.MDF.VEML7700_DATA = () => {
	return {
		timestamp: type_map.unsigned_long(),
		sample_id: type_map.unsigned_long(),
		lux: type_map.float()
	}
};

RTMA.MDF.VEML7700_PING = () => { return {} };

RTMA.MDF.VEML7700_PONG = () => { return {} };

RTMA.MDF.VEML7700_START = () => { return {} };

RTMA.MDF.VEML7700_STOP = () => { return {} };

RTMA.MDF.VEML7700_RESET = () => { return {} };

RTMA.MDF.VEML7700_CONNECT = () => { return {} };

RTMA.MDF.MECH_STIM_CONFIGURE = () => {
	return {
		source: type_map.int(),
		length: type_map.int(),
		str: Array(1024).fill(type_map.char())
	}
};

RTMA.MDF.MECH_STIM_RESET = () => { return {} };

RTMA.MDF.MECH_STIM_STAGE = () => { return {} };

RTMA.MDF.MECH_STIM_WAITING = () => { return {} };

RTMA.MDF.MECH_STIM_TRIGGER = () => { return {} };

RTMA.MDF.MECH_STIM_CANCEL = () => { return {} };

RTMA.MDF.MECH_STIM_DONE = () => { return {} };

RTMA.MDF.MECH_STIM_ERROR = () => { return {} };

RTMA.MDF.UC_MECH_STIM_CONFIGURE = () => {
	return {
		amp: type_map.double(),
		speed: type_map.double(),
		offset: type_map.double(),
		phase: type_map.double(),
		duration: type_map.double(),
		type: type_map.int(),
		padding: type_map.int()
	}
};

// Message Definition Hashes
RTMA.HASH = {};

RTMA.HASH.EXIT = "095e0546";
RTMA.HASH.KILL = "82fc702d";
RTMA.HASH.ACKNOWLEDGE = "b725b581";
RTMA.HASH.FAIL_SUBSCRIBE = "9ad70a15";
RTMA.HASH.FAILED_MESSAGE = "dca545b2";
RTMA.HASH.CONNECT = "6f2e3ca5";
RTMA.HASH.DISCONNECT = "d0126bf9";
RTMA.HASH.SUBSCRIBE = "f5b437c8";
RTMA.HASH.UNSUBSCRIBE = "193fb9e0";
RTMA.HASH.MODULE_READY = "0df81813";
RTMA.HASH.LM_EXIT = "35dd547b";
RTMA.HASH.SAVE_MESSAGE_LOG = "515569e9";
RTMA.HASH.MESSAGE_LOG_SAVED = "66e84ae5";
RTMA.HASH.PAUSE_MESSAGE_LOGGING = "20c1e922";
RTMA.HASH.RESUME_MESSAGE_LOGGING = "0d1a3e77";
RTMA.HASH.RESET_MESSAGE_LOG = "68ec4aab";
RTMA.HASH.DUMP_MESSAGE_LOG = "f9d7e2bf";
RTMA.HASH.TIMING_MESSAGE = "3595c23e";
RTMA.HASH.FORCE_DISCONNECT = "c37c54e8";
RTMA.HASH.PAUSE_SUBSCRIPTION = "22338a6d";
RTMA.HASH.RESUME_SUBSCRIPTION = "c56a97f2";
RTMA.HASH.LM_READY = "4863b960";
RTMA.HASH.JSON_CONFIG = "66be0697";
RTMA.HASH.FINISHED_COMMAND = "dc700a4e";
RTMA.HASH.CONTROL_SPACE_FEEDBACK = "33e67b66";
RTMA.HASH.CONTROL_SPACE_COMMAND = "a477d468";
RTMA.HASH.MPL_RAW_PERCEPT = "7cf55e81";
RTMA.HASH.BIAS_COMMAND = "d150fe3e";
RTMA.HASH.MPL_REBIASED_SENSORDATA = "66bd4b53";
RTMA.HASH.CONTROL_SPACE_FEEDBACK_RHR_GRIPPER = "2dfe82b1";
RTMA.HASH.CONTROL_SPACE_POS_COMMAND = "2356d92e";
RTMA.HASH.MPL_SEGMENT_PERCEPTS = "e35431b7";
RTMA.HASH.WAM_FEEDBACK = "7ac8375a";
RTMA.HASH.IMPEDANCE_COMMAND = "76baa4d5";
RTMA.HASH.EXECUTIVE_CTRL = "51b3116c";
RTMA.HASH.CURSOR_FEEDBACK = "dd4fb481";
RTMA.HASH.VISUAL_GRATING_BUILD = "afe0b860";
RTMA.HASH.VISUAL_GRATING_RESPONSE = "ec3b454d";
RTMA.HASH.GRIP_COMMAND = "bf72edd9";
RTMA.HASH.GRIP_FINISHED_COMMAND = "cf816219";
RTMA.HASH.GRIPPER_FEEDBACK = "04151851";
RTMA.HASH.OPENHAND_CMD = "cce31b3f";
RTMA.HASH.OPENHAND_SENS = "aa0efa7a";
RTMA.HASH.PRENSILIA_SENS = "51634d58";
RTMA.HASH.PRENSILIA_CMD = "49b7b23a";
RTMA.HASH.TABLE_LOAD_CELLS = "193ebc3c";
RTMA.HASH.REZERO_GRIPPER_SENSORS = "8a1d75fd";
RTMA.HASH.SINGLETACT_DATA = "bbe040c8";
RTMA.HASH.GET_USER_RESPONSE = "ba8bf5d0";
RTMA.HASH.USER_RESPONSE_L = "bec98d42";
RTMA.HASH.USER_RESPONSE_R = "5c5e79e3";
RTMA.HASH.RAW_SPIKECOUNT = "fe0b9c40";
RTMA.HASH.SPM_SPIKECOUNT = "2a978201";
RTMA.HASH.SPIKE_SNIPPET = "29c42fa4";
RTMA.HASH.RAW_CTSDATA = "6c2f79c9";
RTMA.HASH.SPM_CTSDATA = "064717f9";
RTMA.HASH.REJECTED_SNIPPET = "c469dd13";
RTMA.HASH.RAW_DIGITAL_EVENT = "0fe8f4be";
RTMA.HASH.SPM_DIGITAL_EVENT = "9dceaace";
RTMA.HASH.STIM_SYNC_EVENT = "5ca0e471";
RTMA.HASH.STIM_UPDATE_EVENT = "8fdd49ac";
RTMA.HASH.CENTRALRECORD = "ccbd685c";
RTMA.HASH.RAW_ANALOGDATA = "74d7d50e";
RTMA.HASH.SPM_ANALOGDATA = "b95489a0";
RTMA.HASH.RAW_SPIKECOUNT_N256 = "a22828c4";
RTMA.HASH.RAW_CTSDATA_N256 = "774eea69";
RTMA.HASH.MECH_SYNC_EVENT = "8c95c514";
RTMA.HASH.SAMPLE_GENERATED = "8251d87a";
RTMA.HASH.XIPP_EMG_DATA_RAW = "ee31a079";
RTMA.HASH.MYO_EMG_DATA = "ebd682da";
RTMA.HASH.MYO_KIN_DATA = "8eb71c1e";
RTMA.HASH.INPUT_DOF_DATA = "62e1c089";
RTMA.HASH.DATAGLOVE = "eba13dd4";
RTMA.HASH.OPTITRACK_RIGID_BODY = "249f100e";
RTMA.HASH.TASK_STATE_CONFIG = "ef302feb";
RTMA.HASH.PHASE_RESULT = "a4dbf676";
RTMA.HASH.EXTRACTION_RESPONSE = "e59bdbc9";
RTMA.HASH.NORMALIZATION_FACTOR = "f1331a30";
RTMA.HASH.TRIAL_METADATA = "7b840f7e";
RTMA.HASH.EXTRACTION_REQUEST = "c5e9a882";
RTMA.HASH.UPDATE_UNIT_STATE = "572242d2";
RTMA.HASH.DISABLED_UNITS = "45a88747";
RTMA.HASH.TRIAL_END = "e939aeee";
RTMA.HASH.REP_START = "3577491d";
RTMA.HASH.REP_END = "c5a8c883";
RTMA.HASH.EXEC_SCORE = "89af766f";
RTMA.HASH.FLIP_THAT_BUCKET_DATA = "2f8be5c6";
RTMA.HASH.SET_START = "7aed5960";
RTMA.HASH.SET_END = "2296961e";
RTMA.HASH.BLOCK_START = "4d2d21a9";
RTMA.HASH.BLOCK_END = "32334bde";
RTMA.HASH.SET_METADATA = "d1ce6c27";
RTMA.HASH.EXEC_PAUSE = "9bc79432";
RTMA.HASH.EM_ADAPT_NOW = "f4c724ce";
RTMA.HASH.EM_CONFIGURATION = "1b33a091";
RTMA.HASH.TDMS_CREATE = "c871d6ed";
RTMA.HASH.RF_REPORT = "c38b43d7";
RTMA.HASH.PICDISPLAY = "80770904";
RTMA.HASH.STIMDATA = "3a3217bc";
RTMA.HASH.SEAIO_OUT = "82125073";
RTMA.HASH.ATIforcesensor = "75acd4a0";
RTMA.HASH.TACTOR_CMD = "94f231b3";
RTMA.HASH.HSTLOG = "04bae81e";
RTMA.HASH.STIM_INTERVAL = "8eba9820";
RTMA.HASH.USER_SHOT_L = "ce9eb33e";
RTMA.HASH.USER_SHOT_R = "f6e9e29a";
RTMA.HASH.STIM_THRESH = "25d0436b";
RTMA.HASH.GAME_ROUND_INFO = "3c98bc4c";
RTMA.HASH.USER_SHOT = "21adc5b1";
RTMA.HASH.GAME_HEARTBEAT_REQUEST = "e5eebd52";
RTMA.HASH.GAME_HEARTBEAT_RESPONSE = "3de2b158";
RTMA.HASH.PLAYSOUND = "ef86c9a0";
RTMA.HASH.PLAYVIDEO = "d690550b";
RTMA.HASH.START_TIMED_RECORDING = "c33e869c";
RTMA.HASH.AJA_CONFIG = "54f3974a";
RTMA.HASH.AJA_TIMECODE = "7096caec";
RTMA.HASH.AJA_STATUS = "0fbfd360";
RTMA.HASH.AJA_STATUS_REQUEST = "31f5b0ef";
RTMA.HASH.FOFIX_PROMPT = "7e937d27";
RTMA.HASH.FOFIX_INPUT = "85ea0a37";
RTMA.HASH.FOFIX_MISSED = "f261d00b";
RTMA.HASH.FOFIX_STIM = "25236bd2";
RTMA.HASH.FOFIX_KEY = "f4baaed3";
RTMA.HASH.CERESTIM_CONFIG_MODULE = "5c5ab75c";
RTMA.HASH.CERESTIM_CONFIG_CHAN_PRESAFETY = "657e8ea3";
RTMA.HASH.CERESTIM_CONFIG_CHAN = "3c5aa623";
RTMA.HASH.CERESTIM_ERROR = "4dbe506f";
RTMA.HASH.CERESTIM_ALIVE = "5c38cb13";
RTMA.HASH.CS_TRAIN_END = "3be6b63c";
RTMA.HASH.CERESTIM_CONFIG_CHAN_PRESAFETY_ARBITRARY = "f7683a07";
RTMA.HASH.CERESTIM_CONFIG_CHAN_ARBITRARY = "dfef8bb0";
RTMA.HASH.CS_ARBITRARY_CLOSE = "62bab05e";
RTMA.HASH.STIM_VOLTAGE_MONITOR_DATA = "cef055cc";
RTMA.HASH.STIM_VOLTAGE_MONITOR_DIGITAL_DATA = "1dbb26b3";
RTMA.HASH.VOLTAGE_MONITOR_STATUS = "d8deb26e";
RTMA.HASH.STIM_DUTYCYCLE_TIME = "13e7c64a";
RTMA.HASH.STIM_TRIAL_DURATION = "526edf6a";
RTMA.HASH.CERESTIM_HEARTBEAT = "c3bdcc1e";
RTMA.HASH.CERESTIM_HEARTBEAT_RQST = "2b0a6017";
RTMA.HASH.CERESTIM_SAFETY_ALIVE = "399aaf24";
RTMA.HASH.CERESTIM_SAFETY_ALIVE_RQST = "cda394a5";
RTMA.HASH.NATURAL_RESPONSE = "275f91d6";
RTMA.HASH.DEPTH_RESPONSE = "185093c9";
RTMA.HASH.PAIN_RESPONSE = "6a633f6e";
RTMA.HASH.OVERALL_INTENSITY_RESPONSE = "fa9babcb";
RTMA.HASH.OTHER_RESPONSE = "a1e76823";
RTMA.HASH.MECH_RESPONSE = "b62f923d";
RTMA.HASH.MOVE_RESPONSE = "53835705";
RTMA.HASH.TINGLE_RESPONSE = "b6a8c7f5";
RTMA.HASH.TEMP_RESPONSE = "140b73c5";
RTMA.HASH.DIR_PIXEL_COORDS = "5f0a710e";
RTMA.HASH.PIXEL_COORDS = "1393ba61";
RTMA.HASH.HOTSPOT_COORDS = "eb94c2bf";
RTMA.HASH.CLEAR_LINE = "8a0d6c36";
RTMA.HASH.CLEAR_HOTSPOT = "660462a8";
RTMA.HASH.ADD_SENSATION = "ee9958c1";
RTMA.HASH.SLIDER_DATA = "b50721b2";
RTMA.HASH.USER_DEFINED_STIM = "a2e9e802";
RTMA.HASH.USER_BEHAVIOUR = "f4e606fb";
RTMA.HASH.STOP_STIM = "ec132898";
RTMA.HASH.PAUSE_TRIAL = "c7eeb83c";
RTMA.HASH.CST_LAMBDA = "f9ebe1b7";
RTMA.HASH.CST_SETTINGS = "2bf099f4";
RTMA.HASH.STIM_PRES_CONFIG = "768880bf";
RTMA.HASH.STIM_PRES_PHASE_END = "c90a3f28";
RTMA.HASH.STIM_PRESENT = "0f4965cb";
RTMA.HASH.STIM_PRES_STATUS = "4984fdfe";
RTMA.HASH.STIM_CONFIG_TYPE = "c7513c8a";
RTMA.HASH.DEKA_ACI_RESPONSE = "5d5cea8f";
RTMA.HASH.DEKA_SENSOR = "fc372ce8";
RTMA.HASH.DEKA_CAN_TOGGLE = "9851db7d";
RTMA.HASH.DEKA_CAN_GRIP_TOGGLE = "90c549b4";
RTMA.HASH.DEKA_CAN_EXIT = "57f16f40";
RTMA.HASH.DEKA_HAND_SENSOR = "941d6442";
RTMA.HASH.DEKA_HAND_JSTICK_CMD = "38e6eafb";
RTMA.HASH.RH_GRIPPER_SENSOR = "e143acf4";
RTMA.HASH.KUKA_JOINT_COMMAND = "44c06dec";
RTMA.HASH.KUKA_FEEDBACK = "800e739a";
RTMA.HASH.KUKA_EXIT = "762b7d36";
RTMA.HASH.KUKA_PTP_JOINT = "bafe0ddf";
RTMA.HASH.KUKA_DEBUG = "951fce38";
RTMA.HASH.VEML7700_SYNC = "fc1f71eb";
RTMA.HASH.VEML7700_DATA = "a8a9380a";
RTMA.HASH.VEML7700_PING = "3ffa1271";
RTMA.HASH.VEML7700_PONG = "4998a3d5";
RTMA.HASH.VEML7700_START = "f328ce11";
RTMA.HASH.VEML7700_STOP = "38498a38";
RTMA.HASH.VEML7700_RESET = "4f76ebab";
RTMA.HASH.VEML7700_CONNECT = "e46f8aa5";
RTMA.HASH.MECH_STIM_CONFIGURE = "88972740";
RTMA.HASH.MECH_STIM_RESET = "dd701d58";
RTMA.HASH.MECH_STIM_STAGE = "ccb8239b";
RTMA.HASH.MECH_STIM_WAITING = "620383b4";
RTMA.HASH.MECH_STIM_TRIGGER = "73f7880c";
RTMA.HASH.MECH_STIM_CANCEL = "8b50f7e0";
RTMA.HASH.MECH_STIM_DONE = "803d4eca";
RTMA.HASH.MECH_STIM_ERROR = "5518c5d1";
RTMA.HASH.UC_MECH_STIM_CONFIGURE = "273bc481";
